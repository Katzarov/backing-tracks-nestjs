import { PassThrough, Readable } from 'node:stream';
import { Buffer } from 'node:buffer';
import { randomUUID } from 'node:crypto';
import { FiLE_EXTENSIONS } from './constants';
import { DiskDriver } from './DiskDriver';
import { S3Driver } from './S3Driver';

export interface TrackFileOptions {
  diskDriver: DiskDriver;
  s3IsEnabled: boolean;
  s3Driver?: S3Driver;
}

export class TrackFile {
  uri: string;
  diskDriver: DiskDriver;
  s3IsEnabled: boolean;
  s3Driver?: S3Driver;

  /**
   * Creates track file object with random uuid as uri.
   * @param options
   */
  constructor(options: TrackFileOptions);

  /**
   * Creates track file object from an existing uuid as uri.
   * @param options
   * @param uri
   */
  constructor(options: TrackFileOptions, uri: string);

  constructor(options: TrackFileOptions, uri?: string) {
    if (uri === undefined) {
      this.uri = randomUUID();
    } else {
      this.uri = uri;
    }

    this.diskDriver = options.diskDriver;
    this.s3IsEnabled = options.s3IsEnabled;

    if (options.s3IsEnabled) {
      this.s3Driver = options.s3Driver;
    }
  }

  /**
   *
   * Saves the mp4 file generated by the YTDL to disk
   *
   * @param stream
   */
  saveYTDLToDisk(stream: Readable | PassThrough) {
    return this.diskDriver.saveStreamToDisk(
      stream,
      this.uri,
      DiskDriver.DownloadsLocation(),
      FiLE_EXTENSIONS.MP4,
    );
  }

  /**
   *
   * Get a readstream to the mp4 file generated by the YTDL
   */
  getYTDLFromDisk() {
    return this.diskDriver.getStreamFromDisk(
      this.uri,
      DiskDriver.DownloadsLocation(),
      FiLE_EXTENSIONS.MP4,
    );
  }

  /**
   *
   * Saves the mp3 file generated by the file-converter to disk
   *
   * @param stream
   */
  saveConvertedTrackToDisk(stream: Readable | PassThrough) {
    return this.diskDriver.saveStreamToDisk(
      stream,
      this.uri,
      DiskDriver.ConvertedLocation(),
      FiLE_EXTENSIONS.MP3,
    );
    // TODO this.cleanUpTempVideo();
  }

  /**
   *
   * Saves the mp3 uploaded by user to disk
   *
   * @param buffer
   */
  saveUploadedTrackToDisk(buffer: Buffer) {
    return this.diskDriver.saveBufferToDisk(
      buffer,
      this.uri,
      DiskDriver.ConvertedLocation(),
      FiLE_EXTENSIONS.MP3,
    );
    // TODO this.cleanUpTempVideo();
  }

  /**
   *
   * Get a readstream to the mp3 file generated by the file-converter or uploaded by user
   */
  getTrackFromDisk() {
    return this.diskDriver.getStreamFromDisk(
      this.uri,
      DiskDriver.ConvertedLocation(),
      FiLE_EXTENSIONS.MP3,
    );
  }

  getTrackDiskPath() {
    return this.diskDriver.getPath(
      this.uri,
      DiskDriver.ConvertedLocation(),
      FiLE_EXTENSIONS.MP3,
    );
  }

  saveTrackToS3(stream: Readable) {
    if (!this.s3IsEnabled) {
      throw new Error("Client shouldn't call when s3 feature is disabled.");
    }
    return this.s3Driver.uploadObject(
      stream,
      `${this.uri}.${FiLE_EXTENSIONS.MP3}`,
    );
  }

  getTrackPresignedUrlFromS3() {
    if (!this.s3IsEnabled) {
      throw new Error("Client shouldn't call when s3 feature is disabled.");
    }
    return this.s3Driver.createPresignedUrl(
      `${this.uri}.${FiLE_EXTENSIONS.MP3}`,
    );
  }
}

